// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package graph

import (
	"bytes"
	"context"
	"embed"
	"errors"
	"fmt"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/Dev-Siri/sero/backend/services/gateway/graph/model"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Mutation() MutationResolver
	Query() QueryResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	AttachmentInfo struct {
		AttachmentID func(childComplexity int) int
	}

	AuthenticatedUser struct {
		AuthType func(childComplexity int) int
		Token    func(childComplexity int) int
		UserID   func(childComplexity int) int
	}

	Mutation struct {
		CompleteAuth      func(childComplexity int, authInfo model.CompleteAuthInput) int
		CreateSession     func(childComplexity int, phone string) int
		Empty             func(childComplexity int) int
		ResendOtp         func(childComplexity int, resendInfo model.ResendOtpInput) int
		RevokePublicKey   func(childComplexity int) int
		UpdateDisplayName func(childComplexity int, newName string) int
		UpdatePictureURL  func(childComplexity int, newPictureAttachmentID string) int
		UpdateStatus      func(childComplexity int, newStatus string) int
		UploadFile        func(childComplexity int, presignedFileInfo model.PresignedFileInfo) int
		UploadPublicKey   func(childComplexity int, publicKey model.PublicKeyInput) int
		VerifyOtp         func(childComplexity int, otp model.OtpInput) int
	}

	Query struct {
		Empty        func(childComplexity int) int
		GetSignedURL func(childComplexity int, fileInfo model.FileInfo) int
		GetUser      func(childComplexity int, userID string) int
	}

	Session struct {
		SessionID func(childComplexity int) int
	}

	SignedUrlInfo struct {
		FileKey   func(childComplexity int) int
		UploadURI func(childComplexity int) int
	}

	User struct {
		CreatedAt   func(childComplexity int) int
		DisplayName func(childComplexity int) int
		Phone       func(childComplexity int) int
		PictureURL  func(childComplexity int) int
		StatusText  func(childComplexity int) int
		UserID      func(childComplexity int) int
	}
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(ctx context.Context, typeName, field string, childComplexity int, rawArgs map[string]any) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "AttachmentInfo.attachmentId":
		if e.complexity.AttachmentInfo.AttachmentID == nil {
			break
		}

		return e.complexity.AttachmentInfo.AttachmentID(childComplexity), true

	case "AuthenticatedUser.authType":
		if e.complexity.AuthenticatedUser.AuthType == nil {
			break
		}

		return e.complexity.AuthenticatedUser.AuthType(childComplexity), true

	case "AuthenticatedUser.token":
		if e.complexity.AuthenticatedUser.Token == nil {
			break
		}

		return e.complexity.AuthenticatedUser.Token(childComplexity), true

	case "AuthenticatedUser.userId":
		if e.complexity.AuthenticatedUser.UserID == nil {
			break
		}

		return e.complexity.AuthenticatedUser.UserID(childComplexity), true

	case "Mutation.completeAuth":
		if e.complexity.Mutation.CompleteAuth == nil {
			break
		}

		args, err := ec.field_Mutation_completeAuth_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CompleteAuth(childComplexity, args["authInfo"].(model.CompleteAuthInput)), true

	case "Mutation.createSession":
		if e.complexity.Mutation.CreateSession == nil {
			break
		}

		args, err := ec.field_Mutation_createSession_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateSession(childComplexity, args["phone"].(string)), true

	case "Mutation._empty":
		if e.complexity.Mutation.Empty == nil {
			break
		}

		return e.complexity.Mutation.Empty(childComplexity), true

	case "Mutation.resendOtp":
		if e.complexity.Mutation.ResendOtp == nil {
			break
		}

		args, err := ec.field_Mutation_resendOtp_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ResendOtp(childComplexity, args["resendInfo"].(model.ResendOtpInput)), true

	case "Mutation.revokePublicKey":
		if e.complexity.Mutation.RevokePublicKey == nil {
			break
		}

		return e.complexity.Mutation.RevokePublicKey(childComplexity), true

	case "Mutation.updateDisplayName":
		if e.complexity.Mutation.UpdateDisplayName == nil {
			break
		}

		args, err := ec.field_Mutation_updateDisplayName_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateDisplayName(childComplexity, args["newName"].(string)), true

	case "Mutation.updatePictureUrl":
		if e.complexity.Mutation.UpdatePictureURL == nil {
			break
		}

		args, err := ec.field_Mutation_updatePictureUrl_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdatePictureURL(childComplexity, args["newPictureAttachmentId"].(string)), true

	case "Mutation.updateStatus":
		if e.complexity.Mutation.UpdateStatus == nil {
			break
		}

		args, err := ec.field_Mutation_updateStatus_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateStatus(childComplexity, args["newStatus"].(string)), true

	case "Mutation.uploadFile":
		if e.complexity.Mutation.UploadFile == nil {
			break
		}

		args, err := ec.field_Mutation_uploadFile_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UploadFile(childComplexity, args["presignedFileInfo"].(model.PresignedFileInfo)), true

	case "Mutation.uploadPublicKey":
		if e.complexity.Mutation.UploadPublicKey == nil {
			break
		}

		args, err := ec.field_Mutation_uploadPublicKey_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UploadPublicKey(childComplexity, args["publicKey"].(model.PublicKeyInput)), true

	case "Mutation.verifyOtp":
		if e.complexity.Mutation.VerifyOtp == nil {
			break
		}

		args, err := ec.field_Mutation_verifyOtp_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.VerifyOtp(childComplexity, args["otp"].(model.OtpInput)), true

	case "Query._empty":
		if e.complexity.Query.Empty == nil {
			break
		}

		return e.complexity.Query.Empty(childComplexity), true

	case "Query.getSignedUrl":
		if e.complexity.Query.GetSignedURL == nil {
			break
		}

		args, err := ec.field_Query_getSignedUrl_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetSignedURL(childComplexity, args["fileInfo"].(model.FileInfo)), true

	case "Query.getUser":
		if e.complexity.Query.GetUser == nil {
			break
		}

		args, err := ec.field_Query_getUser_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetUser(childComplexity, args["userId"].(string)), true

	case "Session.sessionId":
		if e.complexity.Session.SessionID == nil {
			break
		}

		return e.complexity.Session.SessionID(childComplexity), true

	case "SignedUrlInfo.fileKey":
		if e.complexity.SignedUrlInfo.FileKey == nil {
			break
		}

		return e.complexity.SignedUrlInfo.FileKey(childComplexity), true

	case "SignedUrlInfo.uploadUri":
		if e.complexity.SignedUrlInfo.UploadURI == nil {
			break
		}

		return e.complexity.SignedUrlInfo.UploadURI(childComplexity), true

	case "User.createdAt":
		if e.complexity.User.CreatedAt == nil {
			break
		}

		return e.complexity.User.CreatedAt(childComplexity), true

	case "User.displayName":
		if e.complexity.User.DisplayName == nil {
			break
		}

		return e.complexity.User.DisplayName(childComplexity), true

	case "User.phone":
		if e.complexity.User.Phone == nil {
			break
		}

		return e.complexity.User.Phone(childComplexity), true

	case "User.pictureUrl":
		if e.complexity.User.PictureURL == nil {
			break
		}

		return e.complexity.User.PictureURL(childComplexity), true

	case "User.statusText":
		if e.complexity.User.StatusText == nil {
			break
		}

		return e.complexity.User.StatusText(childComplexity), true

	case "User.userId":
		if e.complexity.User.UserID == nil {
			break
		}

		return e.complexity.User.UserID(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	opCtx := graphql.GetOperationContext(ctx)
	ec := executionContext{opCtx, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputCompleteAuthInput,
		ec.unmarshalInputFileInfo,
		ec.unmarshalInputOtpInput,
		ec.unmarshalInputPresignedFileInfo,
		ec.unmarshalInputPublicKeyInput,
		ec.unmarshalInputResendOtpInput,
	)
	first := true

	switch opCtx.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, opCtx.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, opCtx.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

//go:embed "schemas/attachment.graphqls" "schemas/auth.graphqls" "schemas/base.graphqls"
var sourcesFS embed.FS

func sourceData(filename string) string {
	data, err := sourcesFS.ReadFile(filename)
	if err != nil {
		panic(fmt.Sprintf("codegen problem: %s not available", filename))
	}
	return string(data)
}

var sources = []*ast.Source{
	{Name: "schemas/attachment.graphqls", Input: sourceData("schemas/attachment.graphqls"), BuiltIn: false},
	{Name: "schemas/auth.graphqls", Input: sourceData("schemas/auth.graphqls"), BuiltIn: false},
	{Name: "schemas/base.graphqls", Input: sourceData("schemas/base.graphqls"), BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
