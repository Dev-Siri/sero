package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.84

import (
	"context"

	"github.com/Dev-Siri/sero/backend/proto/authpb"
	"github.com/Dev-Siri/sero/backend/services/gateway/graph/model"
	"github.com/Dev-Siri/sero/backend/services/gateway/middleware"
	"github.com/Dev-Siri/sero/backend/shared/logging"
	"go.uber.org/zap"
)

// CreateSession is the resolver for the createSession field.
func (r *mutationResolver) CreateSession(ctx context.Context, phone string) (*model.Session, error) {
	session, err := r.AuthService.CreateSession(ctx, &authpb.SessionRequest{
		Phone: phone,
	})

	if err != nil {
		logging.Logger.Error("resolver 'CreateSession' errored.", zap.Error(err))
		return nil, err
	}

	return &model.Session{SessionID: session.SessionId}, nil
}

// VerifyOtp is the resolver for the verifyOtp field.
func (r *mutationResolver) VerifyOtp(ctx context.Context, otp model.OtpInput) (model.OtpValidityStatus, error) {
	session, err := r.AuthService.VerifyOtp(ctx, &authpb.OtpRequest{
		SessionId: otp.SessionID,
		Otp:       otp.Otp,
	})

	if err != nil {
		logging.Logger.Error("resolver 'VerifyOtp' errored.", zap.Error(err))
		return "", err
	}

	var otpValidityStatus model.OtpValidityStatus

	switch session.OtpValidityStatus {
	case authpb.OtpResponse_EXPIRED_OTP:
		otpValidityStatus = model.OtpValidityStatusExpired
	case authpb.OtpResponse_VALID_OTP:
		otpValidityStatus = model.OtpValidityStatusValid
	default:
		otpValidityStatus = model.OtpValidityStatusInvalid
	}

	return otpValidityStatus, nil
}

// ResendOtp is the resolver for the resendOtp field.
func (r *mutationResolver) ResendOtp(ctx context.Context, resendInfo model.ResendOtpInput) (*bool, error) {
	_, err := r.AuthService.ResendOtp(ctx, &authpb.ResendOtpRequest{
		SessionId: resendInfo.SessionID,
		Phone:     resendInfo.Phone,
	})

	if err != nil {
		logging.Logger.Error("resolver 'ResendOtp' errored.", zap.Error(err))
		return nil, err
	}

	return nil, nil
}

// CompleteAuth is the resolver for the completeAuth field.
func (r *mutationResolver) CompleteAuth(ctx context.Context, authInfo model.CompleteAuthInput) (*model.AuthenticatedUser, error) {
	authedUser, err := r.AuthService.CompleteAuth(ctx, &authpb.CompleteAuthRequest{
		SessionId: authInfo.SessionID,
		Phone:     authInfo.Phone,
	})

	if err != nil {
		logging.Logger.Error("resolver 'CompleteAuth' errored.", zap.Error(err))
		return nil, err
	}

	var authType model.AuthType

	if authedUser.AuthType == authpb.AuthResponse_NEW {
		authType = model.AuthTypeNew
	} else {
		authType = model.AuthTypeExisting
	}

	return &model.AuthenticatedUser{
		UserID:   authedUser.UserId,
		Token:    authedUser.Token,
		AuthType: authType,
	}, nil
}

// UpdateDisplayName is the resolver for the updateDisplayName field.
func (r *mutationResolver) UpdateDisplayName(ctx context.Context, newName string) (*bool, error) {
	user := middleware.AuthFromContext(ctx)

	_, err := r.AuthService.UpdateDisplayName(ctx, &authpb.UpdateDisplayNameRequest{
		UserId:      user.UserId,
		DisplayName: newName,
	})

	if err != nil {
		logging.Logger.Error("resolver 'UpdateDisplayName' errored.", zap.Error(err))
		return nil, err
	}

	return nil, nil
}

// GetUser is the resolver for the getUser field.
func (r *queryResolver) GetUser(ctx context.Context, userID string) (*model.User, error) {
	user, err := r.AuthService.FetchUser(ctx, &authpb.FetchUserRequest{
		UserId: userID,
	})

	if err != nil {
		return nil, err
	}

	return &model.User{
		UserID:      user.UserId,
		Phone:       user.Phone,
		DisplayName: user.DisplayName,
		CreatedAt:   user.CreatedAt,
		StatusText:  user.StatusText,
		PictureURL:  user.PictureUrl,
	}, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
